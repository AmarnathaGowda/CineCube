import numpy as np
from pathlib import Path
import aiofiles
from datetime import datetime
from typing import Optional

from app.core.logger import get_logger
from app.core.errors import LUTGenerationError

logger = get_logger(__name__)

class CubeWriter:
    """Handles writing LUT data in .cube format."""

    def generate_cube_format(
        self,
        lut_data: np.ndarray,
        title: Optional[str] = None
    ) -> str:
        """
        Generate .cube format string from LUT data.
        
        Args:
            lut_data: 3D LUT numpy array
            title: Optional title for the LUT
            
        Returns:
            str: Formatted .cube file content
        """
        try:
            lines = []
            
            # Add header
            lines.append("# Generated by LUT Generator")
            lines.append(f"# Date: {datetime.now().isoformat()}")
            if title:
                lines.append(f"TITLE \"{title}\"")
            
            # Add LUT size
            size = lut_data.shape[0]
            lines.append(f"LUT_3D_SIZE {size}")
            lines.append("")
            
            # Add domain declaration
            lines.append("DOMAIN_MIN 0.0 0.0 0.0")
            lines.append("DOMAIN_MAX 1.0 1.0 1.0")
            lines.append("")
            
            # Add LUT data
            for b in range(size):
                for g in range(size):
                    for r in range(size):
                        values = lut_data[r, g, b]
                        lines.append(f"{values[0]:.6f} {values[1]:.6f} {values[2]:.6f}")
            
            return "\n".join(lines)

        except Exception as e:
            logger.error(f"Error generating CUBE format: {str(e)}")
            raise LUTGenerationError(f"Failed to generate CUBE format: {str(e)}")

    async def save_cube_file(self, cube_data: str, output_path: Path) -> None:
        """
        Save .cube format data to file.
        
        Args:
            cube_data: Formatted .cube file content
            output_path: Path to save the file
        """
        try:
            async with aiofiles.open(output_path, 'w') as f:
                await f.write(cube_data)
            logger.info(f"LUT file saved: {output_path}")
            
        except Exception as e:
            logger.error(f"Error saving CUBE file: {str(e)}")
            raise LUTGenerationError(f"Failed to save CUBE file: {str(e)}")

    def validate_cube_data(self, cube_data: str) -> bool:
        """
        Validate .cube format data.
        
        Args:
            cube_data: Formatted .cube file content
            
        Returns:
            bool: Whether the data is valid
        """
        try:
            lines = cube_data.strip().split("\n")
            
            # Check header
            if not any(line.startswith("LUT_3D_SIZE") for line in lines):
                return False
            
            # Check data format
            data_lines = [line for line in lines if not line.startswith("#") and line.strip()]
            for line in data_lines:
                if line.startswith(("TITLE", "LUT_3D_SIZE", "DOMAIN_MIN", "DOMAIN_MAX")):
                    continue
                    
                # Check if line contains three float values
                try:
                    values = [float(v) for v in line.split()]
                    if len(values) != 3 or any(v < 0 or v > 1 for v in values):
                        return False
                except ValueError:
                    return False
            
            return True
            
        except Exception:
            return False